#!/usr/bin/env -S uv run
from __future__ import annotations

import itertools
import json
import logging
import operator
import os
import re
import shutil
import subprocess
import urllib.request
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from textwrap import dedent
from textwrap import indent as tw_indent
from typing import TYPE_CHECKING, Any, Self

import inflection


if TYPE_CHECKING:
    from collections.abc import Iterator

log_level = getattr(logging, os.environ.get('LOG_LEVEL', 'info').upper())
logging.basicConfig(level=log_level)
logger = logging.getLogger('cdpgen')

REPO_ROOT = Path(__file__).parent.parent

NEWLINE = '\n'

GENERATED_PACKAGE_NOTICE = """\
## Generated by PyCDP

The modules of this package were generated by [pycdp], do not modify their contents because the
changes will be overwritten in next generations.
"""

SHARED_HEADER = """\
# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# Specification verion: {}
#"""

INIT_HEADER = f"""\
{SHARED_HEADER}

"""

MODULE_HEADER = f"""\
{SHARED_HEADER}
#
# CDP domain: {{}}{{}}

from __future__ import annotations

import enum
import typing
from collections.abc import Generator
from dataclasses import dataclass, field
"""

UTIL_IMPORT = """\

from .util import T_JSON_DICT, event_type
"""

current_version = ''

BACKTICK_RE = re.compile(r'`([^`]+)`(\w+)?')


def save_file(data: str, file_path: Path) -> int:
    with file_path.open('w', encoding='utf-8', newline=NEWLINE) as file:
        return file.write(data)


def indent(s: str, n: int) -> str:
    """A shortcut for ``textwrap.indent`` that always uses spaces."""
    return tw_indent(s, n * ' ')


def escape_backticks(docstr: str) -> str:
    """
    Escape backticks in a docstring by doubling them up.

    This is a little tricky because RST requires a non-letter character after
    the closing backticks, but some CDPs docs have things like "`AxNodeId`s".
    If we double the backticks in that string, then it won't be valid RST. The
    fix is to insert an apostrophe if an "s" trails the backticks.
    """

    def replace_one(match: re.Match[str]) -> str:
        if match.group(2) == 's':
            return f"``{match.group(1)}``'s"
        if match.group(2):
            # This case (some trailer other than "s") doesn't currently exist
            # in the CDP definitions, but it's here just to be safe.
            return f'``{match.group(1)}`` {match.group(2)}'
        return f'``{match.group(1)}``'

    # Sometimes pipes are used where backticks should have been used.
    docstr = docstr.replace('|', '`')
    return BACKTICK_RE.sub(replace_one, docstr)


def inline_doc(description: str | None) -> str:
    """Generate an inline doc, e.g. ``#: This type is a ...``"""
    if not description:
        return ''

    description = escape_backticks(description)
    lines = [f'#: {line}' for line in description.split('\n')]
    return '\n'.join(lines)


def docstring(description: str | None) -> str:
    """Generate a docstring from a description."""
    if not description:
        return ''
    # if original description uses escape sequences it should be generated as a raw docstring
    description = escape_backticks(description)

    # VSCode treats r'' and R'' as different string types:
    #  - lowercase r'' are for regex expresions, it will highlight the regex syntax
    #  - uppercase R'' are pure raw strings, no highlingting
    str_prefix = 'R' if '\\' in description else ''
    return f'{str_prefix}"""\n{dedent(description)}\n"""\n'


def is_builtin(name: str) -> bool:
    """Return True if ``name`` would shadow a builtin."""
    import builtins

    try:
        getattr(builtins, name)
    except AttributeError:
        return False
    else:
        return True


def snake_case(name: str) -> str:
    """Convert a camel case name to snake case. If the name would shadow a
    Python builtin, then append an underscore."""
    name = inflection.underscore(name)
    if is_builtin(name):
        name += '_'
    return name


def ref_to_python(ref: str) -> str:
    """
    Convert a CDP ``$ref`` to the name of a Python type.

    For a dotted ref, the part before the dot is snake cased.
    """
    if '.' in ref:
        domain, subtype = ref.split('.')
        ref = f'{snake_case(domain)}.{subtype}'
    return f'{ref}'


def ref_to_python_domain(ref: str, domain: str) -> str:
    if ref.startswith(domain + '.'):
        return ref_to_python(ref[len(domain) + 1 :])
    return ref_to_python(ref)


class CdpPrimitiveType(Enum):
    """All of the CDP types that map directly to a Python type."""

    boolean = 'bool'
    integer = 'int'
    number = 'float'
    object = 'dict'
    string = 'str'

    @classmethod
    def get_annotation(cls, cdp_type: str | None) -> str:
        """Return a type annotation for the CDP type."""
        if not cdp_type or cdp_type == 'any':
            return 'typing.Any'
        return cls[cdp_type].value

    @classmethod
    def get_constructor(cls, cdp_type: str | None, val: str) -> str:
        """Return the code to construct a value for a given CDP type."""
        if not cdp_type or cdp_type == 'any':
            return val
        cons = cls[cdp_type].value
        return f'{cons}({val})'


@dataclass
class CdpItems:
    """Represents the type of a repeated item."""

    type: str
    ref: str | None

    @classmethod
    def from_json(cls, type_: dict[str, str]) -> CdpItems:
        """Generate code to instantiate an item from a JSON object."""
        item_type = type_.get('type', 'any')
        ref = type_.get('$ref')
        if not item_type and not ref:
            msg = f"CdpItems must have a 'type' or a '$ref' field: {type_}"
            raise ValueError(msg)
        return cls(item_type, ref)


@dataclass
class CdpProperty:
    """A property belonging to a non-primitive CDP type."""

    name: str
    description: str | None
    type: str | None
    ref: str | None
    enum: list[str]
    items: CdpItems | None
    optional: bool
    experimental: bool
    deprecated: bool
    domain: str

    @property
    def py_name(self) -> str:
        """Get this property's Python name."""
        return snake_case(self.name)

    @property
    def py_annotation(self) -> str:
        """This property's Python type annotation."""
        if self.items:
            if self.items.ref:
                py_ref = ref_to_python_domain(self.items.ref, self.domain)
                ann = f'list[{py_ref}]'
            else:
                ann = f'list[{CdpPrimitiveType.get_annotation(self.items.type)}]'
        elif self.ref:
            py_ref = ref_to_python_domain(self.ref, self.domain)
            ann = py_ref
        else:
            ann = CdpPrimitiveType.get_annotation(self.type)
        if self.optional:
            ann = f'{ann}' if self.type == 'array' else f'{ann} | None'
        return ann

    @classmethod
    def from_json(cls, prop: dict[str, Any], domain: str) -> Self:
        """Instantiate a CDP property from a JSON object."""
        return cls(
            prop['name'],
            prop.get('description'),
            prop.get('type'),
            prop.get('$ref'),
            prop.get('enum', []),
            CdpItems.from_json(prop['items']) if 'items' in prop else None,
            prop.get('optional', False),
            prop.get('experimental', False),
            prop.get('deprecated', False),
            domain,
        )

    def generate_decl(self) -> str:
        """Generate the code that declares this property."""
        code = inline_doc(self.description)
        if code:
            code += '\n'
        code += f'{self.py_name}: {self.py_annotation}'
        if self.optional:
            code += ' = field(default_factory=list)' if self.type == 'array' else ' = None'
        return code

    def generate_to_json(self, dict_: str, *, use_self: bool = True) -> str:
        """Generate the code that exports this property to the specified JSON
        dict."""
        self_ref = 'self.' if use_self else ''
        assign = f"{dict_}['{self.name}'] = "
        if self.items:
            if self.items.ref:
                assign += f'[i.to_json() for i in {self_ref}{self.py_name}]'
            else:
                assign += f'{self_ref}{self.py_name}'
        elif self.ref:
            assign += f'{self_ref}{self.py_name}.to_json()'
        else:
            assign += f'{self_ref}{self.py_name}'
        if self.optional:
            code = dedent(
                f"""\
                if {self_ref}{self.py_name} is not None:
                    {assign}""",
            )
        else:
            code = assign
        return code

    def generate_from_json(self, dict_: str) -> str:
        """Generate the code that creates an instance from a JSON dict named
        ``dict_``."""
        if self.items:
            if self.items.ref:
                py_ref = ref_to_python_domain(self.items.ref, self.domain)
                expr = f"[{py_ref}.from_json(i) for i in {dict_}.get('{self.name}', [])]"
            else:
                cons = CdpPrimitiveType.get_constructor(self.items.type, 'i')
                expr = f"[{cons} for i in {dict_}.get('{self.name}', [])]"
            if self.optional and self.type != 'array':
                expr += ' or None'

        elif self.ref:
            py_ref = ref_to_python_domain(self.ref, self.domain)
            expr = (
                f"{py_ref}.from_json_optional({dict_}.get('{self.name}'))"
                if self.optional
                else f"{py_ref}.from_json({dict_}['{self.name}'])"
            )

        else:
            expr = CdpPrimitiveType.get_constructor(
                self.type,
                f"{dict_}['{self.name}']",
            )
            if self.optional:
                expr = f"None if {dict_}.get('{self.name}') is None else {expr}"

        return expr


class CdpGenType(Enum):
    Unknown = auto()
    CdpGenEnum = auto()
    CdpGenClass = auto()
    CdpGenPrimitive = auto()


@dataclass
class CdpType:
    """A top-level CDP type."""

    id: str
    description: str | None
    type: str
    items: CdpItems | None
    enum: list[str]
    properties: list[CdpProperty]
    cdpgen_type: CdpGenType = field(init=False)

    def __post_init__(self) -> None:
        self.cdpgen_type = (
            CdpGenType.CdpGenEnum
            if self.enum
            else CdpGenType.CdpGenClass
            if self.properties
            else CdpGenType.CdpGenPrimitive  # keep
        )

    @classmethod
    def from_json(cls, type_: dict[str, Any], domain: str) -> CdpType:
        """Instantiate a CDP type from a JSON object."""
        return cls(
            type_['id'],
            type_.get('description'),
            type_['type'],
            CdpItems.from_json(type_['items']) if 'items' in type_ else None,
            type_.get('enum', []),
            [CdpProperty.from_json(p, domain) for p in type_.get('properties', [])],
        )

    def generate_code(self) -> str:
        """Generate Python code for this type."""
        logger.debug('Generating type %s: %s', self.id, self.type)
        if self.enum:
            return self.generate_enum_code()
        if self.properties:
            return self.generate_class_code()
        return self.generate_primitive_code()

    def generate_primitive_code(self) -> str:
        """Generate code for a primitive type."""
        if self.items:
            if self.items.ref:
                nested_type = ref_to_python(self.items.ref)
            else:
                nested_type = CdpPrimitiveType.get_annotation(self.items.type)
            py_type = f'list[{nested_type}]'
            superclass = 'list'
        else:
            # A primitive type cannot have a ref, so there is no branch here.
            py_type = CdpPrimitiveType.get_annotation(self.type)
            superclass = py_type

        code = f'class {self.id}({superclass}):\n'
        doc = docstring(self.description)
        if doc:
            code += indent(doc, 4) + '\n'

        if self.type == CdpPrimitiveType.string.name:
            str_slots = dedent(
                """\
                __slots__ = ()

                """,
            )
            code += indent(str_slots, 4)

        def_to_json = dedent(
            f"""\
            def to_json(self) -> {py_type}:
                return self""",
        )
        code += indent(def_to_json, 4)

        def_from_json = dedent(
            f"""\
            @classmethod
            def from_json(cls, json: {py_type}) -> {self.id}:
                return cls(json)""",
        )
        code += '\n\n' + indent(def_from_json, 4)

        def_from_json_opt = dedent(
            f"""\
            @classmethod
            def from_json_optional(cls, json: {py_type} | None) -> {self.id} | None:
                if json is None:
                    return None
                return cls.from_json(json)""",
        )
        code += '\n\n' + indent(def_from_json_opt, 4)

        def_repr = dedent(
            f"""\
            def __repr__(self) -> str:
                return f'{self.id}({{super().__repr__()}})'""",
        )
        code += '\n\n' + indent(def_repr, 4)

        return code

    def generate_enum_code(self) -> str:
        """
        Generate an "enum" type.

        Enums are handled by making a python class that contains only class
        members. Each class member is upper snaked case, e.g.
        ``MyTypeClass.MY_ENUM_VALUE`` and is assigned a string value from the
        CDP metadata.
        """
        def_to_json = dedent(
            """\
            def to_json(self) -> str:
                return self.value""",
        )

        def_from_json = dedent(
            f"""\
            @classmethod
            def from_json(cls, json: str) -> {self.id}:
                return cls(json)""",
        )

        def_from_json_opt = dedent(
            f"""\
            @classmethod
            def from_json_optional(cls, json: str | None) -> {self.id} | None:
                if json is None:
                    return None
                return cls.from_json(json)""",
        )

        code = f'class {self.id}(enum.Enum):\n'
        doc = docstring(self.description)
        if doc:
            code += indent(doc, 4) + '\n'
        for enum_member in self.enum:
            snake_name = snake_case(enum_member).upper()
            enum_code = f"{snake_name} = '{enum_member}'\n"
            code += indent(enum_code, 4)
        code += '\n' + indent(def_to_json, 4)
        code += '\n\n' + indent(def_from_json, 4)
        code += '\n\n' + indent(def_from_json_opt, 4)

        return code

    def generate_class_code(self) -> str:
        """
        Generate a class type.

        Top-level types that are defined as a CDP ``object`` are turned into Python
        dataclasses.
        """
        # children = set()
        code = dedent(
            f"""\
            @dataclass
            class {self.id}:\n""",
        )
        doc = docstring(self.description)
        if doc:
            code += indent(doc, 4) + '\n'

        # Emit property declarations. These are sorted so that optional
        # properties come after required properties, which is required to make
        # the dataclass constructor work.
        props = list(self.properties)
        props.sort(key=operator.attrgetter('optional'))
        code += '\n\n'.join(indent(p.generate_decl(), 4) for p in props)
        code += '\n\n'

        # Emit to_json() method. The properties are sorted in the same order as
        # above for readability.
        def_to_json = dedent(
            """\
            def to_json(self) -> T_JSON_DICT:
                json: T_JSON_DICT = {}
        """,
        )
        assigns = (p.generate_to_json(dict_='json') for p in props)
        def_to_json += indent('\n'.join(assigns), 4)
        def_to_json += '\n'
        def_to_json += indent('return json', 4)
        code += indent(def_to_json, 4) + '\n\n'

        # Emit from_json() method. The properties are sorted in the same order
        # as above for readability.
        def_from_json = dedent(
            f"""\
            @classmethod
            def from_json(cls, json: T_JSON_DICT) -> {self.id}:
                return cls(
        """,
        )
        from_jsons = []
        for p in props:
            from_json = p.generate_from_json(dict_='json')
            from_jsons.append(f'{p.py_name}={from_json},')
        def_from_json += indent('\n'.join(from_jsons), 8)
        def_from_json += '\n'
        def_from_json += indent(')', 4)
        code += indent(def_from_json, 4)

        def_from_json_opt = dedent(
            f"""\
            @classmethod
            def from_json_optional(cls, json: T_JSON_DICT | None) -> {self.id} | None:
                if json is None:
                    return None
                return cls.from_json(json)""",
        )
        code += '\n\n' + indent(def_from_json_opt, 4)

        return code

    def get_refs(self) -> set[str]:
        """Return all refs for this type."""
        refs = set()
        if self.enum:
            # Enum types don't have refs.
            pass
        elif self.properties:
            # Enumerate refs for a class type.
            for prop in self.properties:
                if prop.items and prop.items.ref:
                    refs.add(prop.items.ref)
                elif prop.ref:
                    refs.add(prop.ref)
        # A primitive type can't have a direct ref, but it can have an items
        # which contains a ref.
        elif self.items and self.items.ref:
            refs.add(self.items.ref)
        return refs


class CdpParameter(CdpProperty):
    """A parameter to a CDP command."""

    def generate_code(self) -> str:
        """Generate the code for a parameter in a function call."""
        if self.items:
            if self.items.ref:
                nested_type = ref_to_python(self.items.ref)
                py_type = f'list[{nested_type}]'
            else:
                nested_type = CdpPrimitiveType.get_annotation(self.items.type)
                py_type = f'list[{nested_type}]'
        elif self.ref:
            py_type = f'{ref_to_python(self.ref)}'
        else:
            py_type = CdpPrimitiveType.get_annotation(self.type)
        if self.optional:
            py_type = f'{py_type} | None'
        code = f'{self.py_name}: {py_type}'
        if self.optional:
            code += ' = None'
        return code

    def generate_decl(self) -> str:
        """Generate the declaration for this parameter."""
        if self.description:
            code = inline_doc(self.description)
            code += '\n'
        else:
            code = ''
        code += f'{self.py_name}: {self.py_annotation}'
        return code

    def generate_doc(self) -> str:
        """Generate the docstring for this parameter."""
        doc = f':param {self.py_name}:'

        if self.deprecated:
            doc += ' **(DEPRECATED)**'

        if self.experimental:
            doc += ' **(EXPERIMENTAL)**'

        if self.optional:
            doc += ' *(Optional)*'

        if self.description:
            desc = self.description.replace('`', '``').replace('\n', ' ')
            doc += f' {desc}'
        return doc

    def generate_from_json(self, dict_: str) -> str:
        """
        Generate the code to instantiate this parameter from a JSON dict.
        """
        code = super().generate_from_json(dict_)
        return f'{self.py_name}={code}'


class CdpReturn(CdpProperty):
    """A return value from a CDP command."""

    @property
    def py_annotation(self) -> str:
        """Return the Python type annotation for this return."""
        if self.items:
            if self.items.ref:
                py_ref = ref_to_python(self.items.ref)
                ann = f'list[{py_ref}]'
            else:
                py_type = CdpPrimitiveType.get_annotation(self.items.type)
                ann = f'list[{py_type}]'
        elif self.ref:
            py_ref = ref_to_python(self.ref)
            ann = f'{py_ref}'
        else:
            ann = CdpPrimitiveType.get_annotation(self.type)
        if self.optional:
            ann = f'{ann} | None'
        return ann

    def generate_doc(self) -> str:
        """Generate the docstring for this return."""
        if self.description:
            doc = self.description.replace('\n', ' ')
            if self.optional:
                doc = f'*(Optional)* {doc}'
        else:
            doc = ''
        return doc

    def generate_return(self, dict_: str) -> str:
        """Generate code for returning this value."""
        return super().generate_from_json(dict_)


@dataclass
class CdpCommand:
    """A CDP command."""

    name: str
    description: str | None
    experimental: bool
    deprecated: bool
    parameters: list[CdpParameter]
    returns: list[CdpReturn]
    domain: str

    @property
    def py_name(self) -> str:
        """Get a Python name for this command."""
        return snake_case(self.name)

    @classmethod
    def from_json(cls, command: dict[str, Any], domain: str) -> CdpCommand:
        """Instantiate a CDP command from a JSON object."""
        parameters = command.get('parameters', [])
        returns = command.get('returns', [])

        return cls(
            command['name'],
            command.get('description'),
            command.get('experimental', False),
            command.get('deprecated', False),
            [CdpParameter.from_json(p, domain) for p in parameters],
            [CdpReturn.from_json(r, domain) for r in returns],
            domain,
        )

    def generate_code(self) -> str:
        """Generate code for a CDP command."""
        # Generate the function header
        if len(self.returns) == 0:
            ret_type = 'None'
        elif len(self.returns) == 1:
            ret_type = self.returns[0].py_annotation
        else:
            nested_types = ', '.join(r.py_annotation for r in self.returns)
            ret_type = f'tuple[{nested_types}]'

        gen_args = (t for t in ('T_JSON_DICT', 'T_JSON_DICT', ret_type) if t != 'None')
        ret_type = f'Generator[{", ".join(gen_args)}]'

        code = ''

        if self.deprecated:
            code += f'@deprecated(version="{current_version}")\n'

        code += f'def {self.py_name}('
        ret = f') -> {ret_type}:\n'
        if self.parameters:
            code += '\n'
            args = [p for p in self.parameters if not p.optional and p.type != CdpPrimitiveType.boolean.name]

            if not args and len(self.parameters) == 1 and self.parameters[0].type != CdpPrimitiveType.boolean.name:
                args = self.parameters
            if args:
                code += indent(',\n'.join(p.generate_code() for p in args), 4) + ',\n'

            kwargs = [p for p in self.parameters if p not in args]
            if kwargs:
                code += indent('*,\n' + ',\n'.join(p.generate_code() for p in kwargs), 4) + ',\n'
        code += ret

        # Generate the docstring
        doc = ''
        if self.description:
            doc = self.description
        if self.deprecated:
            doc += f'\n\n.. deprecated:: {current_version}'
        if self.experimental:
            doc += '\n\n**EXPERIMENTAL**'
        if self.parameters and doc:
            doc += '\n\n'
        elif not self.parameters and self.returns:
            doc += '\n'
        doc += '\n'.join(p.generate_doc() for p in self.parameters)
        if ret_type.startswith('Generator['):
            # BUG: Fix doc for generator
            doc += '\n' + ':returns: A generator'
            doc += '\n' + f':rtype: {ret_type}'
        elif len(self.returns) == 1:
            ret_doc = self.returns[0].generate_doc()
            doc += '\n' + f':returns: {ret_doc}'
            doc += '\n' + f':rtype: {ret_type}'
        elif len(self.returns) > 1:
            # BUG: Fix doc for tuple
            doc += '\n'
            doc += ':returns: A tuple with the following items:\n\n'
            ret_docs = '\n'.join(f'{i}. **{r.name}** - {r.generate_doc()}' for i, r in enumerate(self.returns))
            doc += indent(ret_docs, 4)
            doc += '\n' + f':rtype: {ret_type}'

        if doc:
            code += indent(docstring(doc), 4)

        # Generate the function body
        if self.parameters:
            code += '\n'
            code += indent('params: T_JSON_DICT = {}', 4)
            code += '\n'
        assigns = (p.generate_to_json(dict_='params', use_self=False) for p in self.parameters)
        code += indent('\n'.join(assigns), 4)
        code += '\n'
        code += indent('cmd_dict: T_JSON_DICT = {\n', 4)
        code += indent(f"'method': '{self.domain}.{self.name}',\n", 8)
        if self.parameters:
            code += indent("'params': params,\n", 8)
        code += indent('}\n', 4)
        code += indent('json = yield cmd_dict', 4)
        if len(self.returns) == 0:
            pass
        elif len(self.returns) == 1:
            ret = self.returns[0].generate_return(dict_='json')
            code += indent(f'\nreturn {ret}', 4)
        else:
            ret = f'\nreturn ({", ".join(r.generate_return(dict_="json") for r in self.returns)})'
            code += indent(ret, 4)
        return code

    def get_refs(self) -> set[str]:
        """Get all refs for this command."""
        refs = set()
        for type_ in itertools.chain(self.parameters, self.returns):
            if type_.items and type_.items.ref:
                refs.add(type_.items.ref)
            elif type_.ref:
                refs.add(type_.ref)
        return refs


@dataclass
class CdpEvent:
    """A CDP event object."""

    name: str
    description: str | None
    deprecated: bool
    experimental: bool
    parameters: list[CdpParameter]
    domain: str

    @property
    def py_name(self) -> str:
        """Return the Python class name for this event."""
        return inflection.camelize(self.name, uppercase_first_letter=True)

    @classmethod
    def from_json(cls, json: dict[str, Any], domain: str) -> CdpEvent:
        """Create a new CDP event instance from a JSON dict."""
        return cls(
            json['name'],
            json.get('description'),
            json.get('deprecated', False),
            json.get('experimental', False),
            [CdpParameter.from_json(p, domain) for p in json.get('parameters', [])],
            domain,
        )

    def generate_code(self) -> str:
        """Generate code for a CDP event."""
        code = dedent(
            f"""\
            @event_type('{self.domain}.{self.name}')
            @dataclass
            class {self.py_name}:""",
        )

        if self.deprecated:
            code = f'@deprecated(version="{current_version}")\n' + code

        code += '\n'
        desc = ''
        if self.description or self.experimental:
            if self.experimental:
                desc += '**EXPERIMENTAL**\n\n'

            if self.description:
                desc += self.description

            code += indent(docstring(desc), 4)
            code += '\n'

        code += indent('\n'.join(p.generate_decl() for p in self.parameters), 4)
        code += '\n\n'
        def_from_json = dedent(
            f"""\
            @classmethod
            def from_json(cls, json: T_JSON_DICT) -> {self.py_name}:
                return cls(""",
        )
        code += indent(def_from_json, 4)
        params = [p.generate_from_json(dict_='json') for p in self.parameters]
        params_len = sum(len(p) + len(', ') for p in params)
        if params_len > 60:
            code += '\n' + indent(',\n'.join(params), 12) + ',\n'
            code += indent(')', 8)
        else:
            code += ', '.join(params) + ')'

        def_from_json_opt = dedent(
            f"""\
            @classmethod
            def from_json_optional(cls, json: T_JSON_DICT | None) -> {self.py_name} | None:
                if json is None:
                    return None
                return cls.from_json(json)""",
        )
        code += '\n\n' + indent(def_from_json_opt, 4)

        return code

    def get_refs(self) -> set[str]:
        """Get all refs for this event."""
        refs = set()
        for param in self.parameters:
            if param.items and param.items.ref:
                refs.add(param.items.ref)
            elif param.ref:
                refs.add(param.ref)
        return refs


@dataclass
class CdpDomain:
    """A CDP domain contains metadata, types, commands, and events."""

    domain: str
    description: str | None
    experimental: bool
    dependencies: list[str]
    types: list[CdpType]
    commands: list[CdpCommand]
    events: list[CdpEvent]

    @property
    def module(self) -> str:
        """The name of the Python module for this CDP domain."""
        return snake_case(self.domain)

    @classmethod
    def from_json(cls, domain: dict[str, Any]) -> CdpDomain:
        """Instantiate a CDP domain from a JSON object."""
        types = domain.get('types', [])
        commands = domain.get('commands', [])
        events = domain.get('events', [])
        domain_name = domain['domain']

        return cls(
            domain_name,
            domain.get('description'),
            domain.get('experimental', False),
            domain.get('dependencies', []),
            [CdpType.from_json(type, domain_name) for type in types],
            [CdpCommand.from_json(command, domain_name) for command in commands],
            [CdpEvent.from_json(event, domain_name) for event in events],
        )

    def generate_code(self) -> str:
        """Generate the Python module code for a given CDP domain."""
        exp = ' (experimental)' if self.experimental else ''
        code = MODULE_HEADER.format(current_version, self.domain, exp)
        code += self.generate_imports()
        code += UTIL_IMPORT
        code += self.generate_lint_rules()
        code += '\n\n'

        item_iter: Iterator[CdpEvent | CdpCommand | CdpType] = itertools.chain(
            iter(self.types),
            iter(self.commands),
            iter(self.events),
        )
        code += '\n\n\n'.join(item.generate_code() for item in item_iter)
        code += '\n'
        return code

    def generate_imports(self) -> str:
        """
        Determine which modules this module depends on and emit the code to
        import those modules.

        Notice that CDP defines a ``dependencies`` field for each domain, but
        these dependencies are a subset of the modules that we actually need to
        import to make our Python code work correctly and type safe. So we
        ignore the CDP's declared dependencies and compute them ourselves.
        """
        refs = set()
        code = ''
        needs_deprecation = False
        for type_ in self.types:
            refs |= type_.get_refs()
        for command in self.commands:
            refs |= command.get_refs()
            if command.deprecated:
                needs_deprecation = True
        for event in self.events:
            refs |= event.get_refs()
            if event.deprecated:
                needs_deprecation = True
        dependencies = set()
        for ref in refs:
            try:
                domain, _ = ref.split('.')
            except ValueError:
                continue
            if domain != self.domain:
                dependencies.add(snake_case(domain))
        if dependencies:
            code += '\n' + f'from . import {", ".join(d for d in sorted(dependencies))}'

        if needs_deprecation:
            code += '\nfrom deprecated.sphinx import deprecated'

        return code

    def generate_lint_rules(self) -> str:
        # Always add these rules, they will be removed if not useful
        disabled_rules: set[str] = {'S105'}

        for cdp_type in self.types:
            if cdp_type.cdpgen_type == CdpGenType.CdpGenEnum:
                continue

            if cdp_type.type == CdpPrimitiveType.string.name:
                disabled_rules.add('FURB189')

            if cdp_type.type == CdpPrimitiveType.object.name and cdp_type.cdpgen_type == CdpGenType.CdpGenPrimitive:
                disabled_rules.add('FURB189')

            if cdp_type.type == 'array' and cdp_type.cdpgen_type == CdpGenType.CdpGenPrimitive:
                disabled_rules.add('FURB189')

        if disabled_rules:
            return dedent(
                f"""

                # ruff: noqa: {', '.join(sorted(disabled_rules))}
                """,
            )
        return ''


def parse(json_path: Path, output_path: Path) -> list[CdpDomain]:
    """
    Parse JSON protocol description and return domain objects.

    :param Path json_path: path to a JSON CDP schema
    :param Path output_path: a directory path to create the modules in
    :returns: a list of CDP domain objects
    """
    global current_version  # noqa: PLW0603
    with json_path.open(encoding='utf-8') as json_file:
        schema = json.load(json_file)
    version = schema['version']
    assert (version['major'], version['minor']) == ('1', '3')
    current_version = f'{version["major"]}.{version["minor"]}'
    return [CdpDomain.from_json(domain) for domain in schema['domains']]


def generate_init(init_path: Path, domains: list[CdpDomain]) -> None:
    """
    Generate an ``__init__.py`` that exports the specified modules.

    :param Path init_path: a file path to create the init file in
    :param list[tuple] domains: a list of modules each represented as tuples
        of (name, list_of_exported_symbols)
    """
    sorted_domains = sorted(domains, key=operator.attrgetter('module'))
    save_file(
        INIT_HEADER.format(current_version)
        + '\n'.join(f'from . import {domain.module} as {domain.module}' for domain in sorted_domains)
        + '\n',
        init_path,
    )


def fix_protocol_spec(domains: list[CdpDomain]) -> None:
    """Fixes following errors in the official CDP spec:
    1. DOM includes an erroneous $ref that refers to itself.
    2. Page includes an event with an extraneous backtick in the description.
    3. Network.Cookie.expires is optional because sometimes its value can be null."""
    for domain in domains:  # noqa: PLR1702
        if domain.domain == 'DOM':
            for cmd in domain.commands:
                if cmd.name == 'resolveNode':
                    # Patch 1
                    cmd.parameters[1].ref = 'BackendNodeId'
                    break
        elif domain.domain == 'Page':
            for event in domain.events:
                if event.name == 'screencastVisibilityChanged':
                    # Patch 2
                    event.description = (event.description or '').replace('`', '')
                    break
        elif domain.domain == 'Network':
            for _type in domain.types:
                if _type.id == 'Cookie':
                    for prop in _type.properties:
                        if prop.name == 'expires':
                            prop.optional = True
                            break


def format_files(output_path: Path, *, lint_before: bool = False, verbose: bool = False) -> None:
    """Format the generated code."""

    args = [
        'uv',
        'run',
        'ruff',
        'cmd',
        '--no-force-exclude',
        '--preview',
        '-v',
    ]

    if not verbose:
        args.remove('-v')

    cmd_pos = args.index('cmd')
    lint_args = args.copy()
    lint_args[cmd_pos] = 'check'
    lint_args.extend([
        '--fix',
        '--unsafe-fixes',
    ])

    fmt_args = args.copy()
    fmt_args[cmd_pos] = 'format'

    def run_linter(cmd_name: str, args: list[str]) -> None:
        result = subprocess.run(  # noqa: S603
            [
                *args,
                str(output_path),
                # '--config',
                # str(REPO_ROOT / 'pyproject.toml'),
            ],
            check=False,
            cwd=REPO_ROOT,
        )
        if result.returncode != 0:
            logger.warning(
                '%s the generated files failed with error code %d.',
                f'{cmd_name.capitalize()}ing',
                result.returncode,
            )

    if lint_before:
        for _ in range(2):
            run_linter('lint', lint_args)
            run_linter('format', fmt_args)
    else:
        run_linter('format', fmt_args)


def main() -> None:
    """Generate CDP types and docs for ourselves"""
    json_paths = [
        REPO_ROOT / 'browser_protocol.json',
        REPO_ROOT / 'js_protocol.json',
    ]
    for p in json_paths:
        if not p.exists():
            dl_file(p.name)

    output_path = REPO_ROOT / 'zendriver' / 'cdp'

    if output_path.exists():
        shutil.rmtree(output_path)
    output_path.mkdir(exist_ok=True)
    try:
        # Parse domains
        domains: list[CdpDomain] = []
        for json_path in json_paths:
            logger.info('Parsing JSON file %s', json_path)
            domains.extend(parse(json_path, output_path))
        domains.sort(key=operator.attrgetter('domain'))
        fix_protocol_spec(domains)
        for domain in domains:
            logger.info('Generating module: %s â†’ %s.py', domain.domain, domain.module)
            module_path = output_path / f'{domain.module}.py'
            save_file(domain.generate_code(), module_path)

        util_path = output_path / 'util.py'
        util_path.unlink(missing_ok=True)
        util_source = Path(__file__).parent / '_util_template.py'
        shutil.copyfile(util_source, util_path)

        # Fake domain used to add module 'util' to the __init__ file
        util_domain = CdpDomain(
            domain='util',
            description=None,
            experimental=False,
            dependencies=[],
            types=[],
            commands=[],
            events=[],
        )

        generate_init(output_path / '__init__.py', [*domains, util_domain])
        save_file(GENERATED_PACKAGE_NOTICE, output_path / 'README.md')
        (output_path / 'py.typed').touch()

        # format_files(output_path, verbose=True)
        format_files(output_path, lint_before=True)

    finally:
        [x.unlink() for x in json_paths]


def dl_file(filename: str, path: Path | None = None) -> None:
    r = urllib.request.urlretrieve(
        f'https://raw.githubusercontent.com/ChromeDevTools/devtools-protocol/master/json/{filename}',
        filename=path or filename,
    )

    pass


if __name__ == '__main__':
    main()
